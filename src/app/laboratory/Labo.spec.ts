import {IPcs} from "../core/IPcs";
import {GroupAction} from "../core/GroupAction";
import {Group} from "../core/Group";
import {MusaicPcsOperation} from "../core/MusaicPcsOperation";
import {EightyEight} from "../utils/EightyEight";


describe('Laboratory explorer', () => {

  /////////// Math POC

  /**
   * <pre>
   * |Orbit(x)| = |G| / |Stab(x)|
   * </pre>
   *
   * i.e. cardinal of an orbit o is equals to the number operations of group
   * div by number stabilized operations of any element of the orbit o
   *
   * @see https://en.wikipedia.org/wiki/Group_action#Orbit-stabilizer_theorem_and_Burnside.27s_lemma
   */
  it('test_Orbit_Stabilizer_Theorem', () => {
    const groupMusaic = GroupAction.predefinedGroupsActions(12, Group.MUSAIC)
    groupMusaic.orbits.forEach((orbit) => {
      const min: IPcs = orbit.getPcsMin()
      expect(orbit.cardinal).toEqual(groupMusaic.cardinal / min.stabilizer.cardinal)
    })
  })


  /**
   * <pre>
   * orbit-counting theorem - Burnside's lemma
   * |X/G| = (sum |Fix.g| for all g in G) / |G|
   * </pre>
   *
   * \left|X/G\right|={\frac {1}{\left|G\right|}}\sum _{g\in
   * G}\left|X^{g}\right|,
   *
   * @see https://en.wikipedia.org/wiki/Burnside%27s_lemma
   */
  it('test_Orbit_Counting_Theorem_Burnside', () => {
    const groupMusaic = GroupAction.predefinedGroupsActions(12, Group.MUSAIC)
    expect(groupMusaic.operations.length).toEqual(96)

    const totalCardFixedPcs = groupMusaic.operations.reduce(
      (cardFixedPcs: number, currentValue) =>
        currentValue.getFixedPcs().length + cardFixedPcs,
      0)

    expect(8448).toEqual(totalCardFixedPcs);

    // expect that 88 = 8448 / 96
    expect(groupMusaic.orbits.length).toEqual(totalCardFixedPcs / groupMusaic.operations.length);
    // same
    expect(88).toEqual(totalCardFixedPcs / 96);

  })

  /////////// Explore PCS lists


  it('List of scales grouped by same IV', () => {
    const groupCyclic = GroupAction.predefinedGroupsActions(12, Group.CYCLIC)
    expect(groupCyclic.operations.length).toEqual(12)
    expect(groupCyclic.orbits.length).toEqual(352)

    const pcsGroupedBySameIV = new Map<string, IPcs[]>
    for (const orbit of groupCyclic.orbits) {
      const pcsPF = orbit.getPcsMin()
      if (!pcsGroupedBySameIV.has(pcsPF.iv().toString())) {
        pcsGroupedBySameIV.set(pcsPF.iv().toString(), [pcsPF])
      } else {
        pcsGroupedBySameIV.get(pcsPF.iv().toString())!.push(pcsPF)
      }
    }
    // check how many groupings are there
    console.log("pcsGroupedByIV.size = " + pcsGroupedBySameIV.size)

    // TODO find reference !
    expect(pcsGroupedBySameIV.size).toEqual(200)

    console.log("Example pcs with same IV() : " + Array.from(pcsGroupedBySameIV.values())[43])

    // show pcs that are alone in this grouping
    let soloIV = 0
    let nbPcsWithIVequal4 = 0
    let nbPcsWithIVequal2 = 0
    let nbPcsWithIVequal3 = 0
    for (const pcsGroupingByIV of pcsGroupedBySameIV) {
      if (pcsGroupingByIV[1].length == 4) {
        console.log("iv (" + pcsGroupingByIV[0] + ") partagé par : " + pcsGroupingByIV[1].length + " pcs")
        nbPcsWithIVequal4++
      } else if (pcsGroupingByIV[1].length == 3) {
        console.log("iv (" + pcsGroupingByIV[0] + ") partagé par : " + pcsGroupingByIV[1].length + " pcs")
        nbPcsWithIVequal3++
      } else if (pcsGroupingByIV[1].length == 2) {
        nbPcsWithIVequal2++
      } else if (pcsGroupingByIV[1].length == 1) {
        soloIV++
      }
    }
    console.log("nb pcs with unique iv() : " + soloIV)
    console.log("nb pcs (into 352) shearing iv with more than exactly 2 others : " + nbPcsWithIVequal2)
    console.log("nb pcs (into 352) shearing iv with more than exactly 3 others : " + nbPcsWithIVequal3)
    console.log("nb pcs (into 352) shearing iv with more than 3 others : " + nbPcsWithIVequal4)

    expect(nbPcsWithIVequal2).toEqual(112)

    // do get 352 pcs, so groupCyclic.orbits.length
    expect(nbPcsWithIVequal4 * 4 + nbPcsWithIVequal3 * 3 + nbPcsWithIVequal2 * 2 + soloIV).toEqual(352)

  });


  it('Test powerset grouped by is() Pascal Triangle', () => {
    const groupCyclic = GroupAction.predefinedGroupsActions(12, Group.CYCLIC)
    const mapIs = new Map<string, IPcs[]>()
    for (const pcs of groupCyclic.powerset.values()) {
      let pcsIs = pcs.is().toString()
      if (mapIs.has(pcsIs)) {
        mapIs.get(pcsIs)!.push(pcs)
      } else {
        mapIs.set(pcsIs, [pcs])
      }
    }
    expect(mapIs.size).toEqual(groupCyclic.powerset.size / 2 + 1) // 2048+1, empty matter 1 ??

    let arrayCard = Array(13).fill(0)

    for (const entryPcs of mapIs) {
      arrayCard[entryPcs[1].length]++
    }

    for (let i = (0 + 1); i < arrayCard.length; i++) {
      console.log(`[${i}] = ${arrayCard[i]}`)
    }

  })


  it('Explore sub-group of musaic group', () => {
    // let M1_T0 = new MusaicPcsOperation(12, 1, 0); generated by M1_T1
    let M1_T1 = new MusaicPcsOperation(12, 1, 1);
    let M5_T1 = new MusaicPcsOperation(12, 5, 0);
    let M7_T1 = new MusaicPcsOperation(12, 7, 0);
    let M11_T1 = new MusaicPcsOperation(12, 11, 0);
    let CM1_T1 = new MusaicPcsOperation(12, 1, 0, true);
    let CM5_T1 = new MusaicPcsOperation(12, 5, 0, true);
    let CM7_T1 = new MusaicPcsOperation(12, 7, 0, true);
    let CM11_T1 = new MusaicPcsOperation(12, 11, 0, true);
    const allOperations = [M5_T1, M7_T1, M11_T1, CM1_T1, CM5_T1, CM7_T1, CM11_T1]

    const numberOps = allOperations.length
    expect(numberOps).toEqual(7)
    const cardinalPowerset = Math.pow(2, numberOps)
    expect(cardinalPowerset).toEqual(128)

    // key = group name, value = some operations group generator
    let generatorGroup = new Map<string, MusaicPcsOperation[][]>()

    // key = group name, value = orbits cardinal (number of orbits generated by group action)
    let groupComputed = new Map<string, number>()

    let groupAction: GroupAction
    for (let i = 0; i < cardinalPowerset; i++) {
      const pcs = new IPcs({pidVal: i, n: numberOps})
      let someOperations = [M1_T1] // include M1-T0
      for (let j = 0; j < pcs.abinPcs.length; j++) {
        if (pcs.abinPcs[j] == 1) {
          someOperations.push(allOperations[j])
        }
      }
      let group = new Group(someOperations)
      // console.log(someOperations + " => groupe.name =" + group.name)
      if (!groupComputed.has(group.name)) {
        generatorGroup.set(group.name, [someOperations])
        // console.log("=> " + group.name)
        groupAction = new GroupAction({n: 12, someMusaicOperations: someOperations});
        groupComputed.set(group.name, groupAction.orbits.length)
      } else {
        generatorGroup.get(group.name)?.push(someOperations)
      }
    }

    expect(generatorGroup.size).toEqual(16)

    // sort on number of orbits
    groupComputed = new Map([...groupComputed.entries()].sort((a, b) =>
      b[1] - a[1]
    ))
    console.log("groupComputed.size = " + groupComputed.size) // 16 groups
    console.log("== Sub groups (" + groupComputed.size + ") ===================================")
    for (const e of groupComputed) {
      console.log(e[0] + " => " + e[1])
    }
    console.log()
    console.log("== Generators family (operations group) ===================================")
    for (const e of groupComputed) {
      console.log(e[0] + " => " + e[1])
      console.log(" generators (" + generatorGroup.get(e[0])?.length + ") =")
      generatorGroup.get(e[0])?.forEach((g) =>
        console.log([...g].map((op) => op.toString())))
      console.log("=====================================")
    }
  })

  /**
   * Specification of Major Scale is it shared by others scales ?
   * Intervallic structure major scale : 2,2,1,2,2,2,1
   */
  it("Get scales composed only by intervals 1 and 2, with no more two 1 consecutive", () => {
    const groupCyclic = GroupAction.predefinedGroupsActions(12, Group.CYCLIC)
    const scalesWithOnly_1_2_intervals =
      groupCyclic.orbits
        .filter(orbit => orbit.getPcsMin().is().every(bit => [1, 2].includes(bit)))
        .filter(orbit => orbit.getPcsMin().is().some(bit => bit === 1))

    // 32 - whole tone scale and [] (empty scale ??) ==> 30
    expect(scalesWithOnly_1_2_intervals.length).toEqual(30)

    // scalesWithOnly_1_2_intervals.forEach(
    //   orbit => console.log(orbit.getPcsMin().is() + " Mus n° " + EightyEight.idNumberOf(orbit.getPcsMin())))

    // no more two 1 consecutive
    const res = scalesWithOnly_1_2_intervals.filter(orbit => {
      const is = orbit.getPcsMin().is()
      let cpt1successive = 0
      let cpt2successive = 0

      for (let i = 0; i < is.length; i++) {
        if (is[i] === 1) {
          cpt1successive++
          if (cpt1successive > 1) return false
          cpt2successive = 0
        } else { // is[i] === 2
          cpt2successive++
          //if (cpt0>4) return false
          cpt1successive = 0
        }
      }
      return cpt2successive > 0 || cpt1successive > 0
    })
    res.forEach(orbit =>
      console.log(orbit.getPcsMin().is() + " Mus n° " + EightyEight.idNumberOf(orbit.getPcsMin())))
    expect(res.length).toEqual(3)
  })

  it ("intervallic structure feature", ()=> {
    const majScale = new IPcs({strPcs:"0,2,4,5,7 ,9 ,11"})
    const featureIS = majScale.getFeatureIS()
    const featureWaiting = [1, 2]
    expect(featureIS).toEqual(featureWaiting)
  })

  it ("get all pcs having same featureIS", ()=> {
    const majScale = new IPcs({strPcs:"0,2,4,5,7 ,9 ,11"})
    const pcsSameFeatureIS : IPcs[] = majScale.getPcsSameFeatureIS()
    pcsSameFeatureIS.forEach(pcs => console.log(pcs.is() + " Mus n° " + EightyEight.idNumberOf(pcs)))
    expect(pcsSameFeatureIS.length).toEqual(29) // 30 - chromatic scale
  })

  // TODO see centre de gravité ?

})
