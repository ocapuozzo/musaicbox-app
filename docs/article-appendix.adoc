:imagesdir: ./assets/images

== Appendix


=== Axis and its identifiers

While an A-type axis passes through a pitch-class, B-type axis is stem:[± 1/2] from a pitch-class number.

As all transformations are always *pitch-class-pivot centred*, the axis passes perpendicularly through a midpoint of the segment defined by the pairs stem:[(p, p+k)], even in the case where stem:[k = 0].

We can see a B-type axis as passing through the midpoint of the segment defined by two pitch-class numbers.

For example, the operation below defines an axis of `[2 4 5 6 7]` passing through pitch-class numbers *_2_* and *_3_*.

image:pcs-24567-axe-B.png[] `T~1~M11~2~` -> image:pcs-0131011-axe-B.png[]

The B-type axis is to stem:[k/2] from pitch-class pivot number 2, {nbsp} so stem:[1/2 + 2].

Let us see how D. Lewin solves this case by examining the inversion operator
stem:[I^(a,b)].

Since a B-type symmetry axis cannot be identified by a single pitch-class, D. Lewin <<LEWIN-1977a>> decided to represent any axes, A and B type, by a pair of pitch-classes. He called his function _I^uv^_ (centered on the inversion function), but we will use _a,b_ or _I^a,b^_, with comma separator, for greater readability and to emphasize the concept of a line segment [ab].

Here is Lewin's equivalent version to the affine version with pivot of the example above: `T~0~M11~2~`

[.text-center]
image::syntax-affine-inversion-ab.png[]

// `T~0~M11~2~` stem:[equiv] `M11~2~`  stem:[equiv] `I^2^` stem:[equiv] `I^2,2^`

Let us look at Lewin's parametric inversion operator.
//
// We have as many choices of axis type *_A_* as there are pitch-classes in the pitch-class set (given by its cardinal). But what about the other axes of type *_A_* and  *_B_*?

==== Lewin inversion operator

In a 1968 article of D. Lewin <<LEWIN-1968>>  _"Inversional Balance as an Organizing Force in Schoenberg's Music and Thought"_  D. Lewin wrote: _"We may think of these pitch-class inversions_ [pair of pitch-classes] _as possessing 'axes' "_ and he explain how _"balance of the total chromatic induced by the functioning of such an inversion_ [...] _as something quite analogous of the balance induced by a tonal center"_.

.Lewin (1968), "Inversional Balance in chromatic system"
image::balance-inversion.png[]

Later (1977), D. Lewin introduced the inversion operator stem:[I^(uv)].

This inversion operator stem:[I^(a, b)] (<<LEWIN-1977a>>, <<LEWIN-1980>>)
allows you to specify a *pivot symmetry axis* for inversion, by designating a pair stem:[(a,b)] of pitch-classes.

// footnote:[Lewin most often uses the names _u_ and _v_ to denote this pair. We us _ab_ for to emphasize the notion of linear segment].

[.text-center]
stem:[I^(a, b)] an "_inversion taking a to b_".

Defining an axis of symmetry by a pair of numbers stem:[(a,b)] allows us to designate an axis passing through the center of the circle and the middle of the segment formed by stem:[a] and stem:[b] : stem:["midpoint("bar(ab)")" = 1/2 (a+b) ].


[.text-center]
image::axes-symmetry-type-A-B.png[]
[.text-center]
Ex. 1: Identify A-type axis with pairs: (2,2), (1,3)... and Ex. 2: B-type axis with pairs: (0,1), (11,2)...

Whether the axes are of type A or B, the calculation of the axis position remains the same stem:[(a+b)/2]. This works for axes of symmetry of type A and B. Indeed, if a = b, then the axis will pass through stem:[(2a)/2 = a], and Lewin suggests denoting such segments stem:[(a,a)], for an axis of type A, simply by stem:[a], which is then synonymous with _p_ (pivot value):

[.text-center]
stem:[I^(a,a) = I^a]
//{nbsp}{nbsp}{nbsp}so{nbsp}{nbsp}{nbsp} stem:[I^(a,a) equiv T_0M11_a]

Let's go back to our example, the B-type axis passes between two pitch-class numbers, 2 and 3. Therefore, a solution to the problem posed is: `I^2,3^`.

[.text-center]
image:pcs-24567-axe-B.png[] `I^2,3^` -> image:pcs-0131011-axe-B.png[]

[.text-center]
`I^2,3^([2 4 5 6 7]) = [0 1 3 10 11]`


That said, technically there are _n_ possible expressions of (_a,b_) to specify a same axis (type A or B). See appendix <<Numbers of pairs identifying an axis>>.

To return to our example problem of B-type axis with `[2 4 5 6 7]`, there are `cardinal([2 4 5 6 7]) * 2 = 10` pairs of solution: . `I^2,3^`, `I^1,4^`, `I^0,5^`, `I^11,6^`, `I^10,7^` and their inverse. Examples:

[.text-center]
`I^2,3^([2 4 5 6 7]) = I^1,4^([2 4 5 6 7]) ... = I^7,10^([2 4 5 6 7]) = [0 1 3 10 11]`


[caption=""]
.Illustration
====
image:pcs-24567-axe-segments.png[]{nbsp}{nbsp} stem:[I^(a,b) |->  I^(2,3) = I^(1,4) ... = I^(7,10)] and their inverse stem:[I^(3,2) = I^(4,1)] etc.
====

// - or cardinal(pcs) if we constrain the first argument to be in pcs argument (eligible p-value).

We will now see the relationship between this functionality and the affine system with pivot.

====  Compare with affine pivot

We begin our analysis with a characteristic of stem:[I^(u v)], highlighted by David Lewin in _A label-free development_ p. 36 and proof p. 45 <<LEWIN-1977a>> (and <<LEWIN-1980>>), and which happens to be the key to resolve our problem:

[.text-center]
stem:[T_iI^(u,v) = I^(u,w)] where stem:[w = T_i(v)] +
(_we've added a separator between *u* and *v* for clarity_)

The idea behind this is that an axis is defined by a fixed point and a variable part represented by a transposition value.

Let us rewrite this formula, assuming that we are in modulo _n_ logic, and rename _u v_ by _a b_.
[.text-center]
stem:[T_iI^(a,b) = I^(a,b+i)]

Let's look at the special case where stem:[a=b]:


[.text-center]
stem:[T_iI^(a) = I^(a,a+i)]


We know that expression stem:[T_iI^a] is noted stem:[T_iM11_a] in affine pivot system version ("_a_" designated the pivot-value "_p_" for A-type symmetry axis).  We can therefore bring these two notations together:

// [.text-center]
// stem:[T_kI^(p) = I^(p,p+k) = T_kM11_p]

[.text-center]
stem:[ubrace(I^(p,p+k) = T_kI^p)_"Lewin syntax"\ \  <=> ubrace(T_kM11_p)_"Affine pivot syntax"]


It becomes clear that is the value of _k_ that defines the orientation of the axis (by the segment [.nowrap]#(_p, p + k_)#).


In other words, _k_ is an *offset* value of the symmetry axis relative to the pitch-class-pivot.


The midpoint of stem:[(p,p+k)] is stem:[(2p+k)/2 = p + k/2]

The type of the symmetry axis (A or B) depends essentially on _k_.

Examples of median (A) and inter (B) midpoint axis at{nbsp}stem:[p + k/2] :

|===
^|(k even) +
midpoint _m_ = stem:[p + k/2] ^|(k odd) +
_m_ = stem:[p + k/2]{nbsp}{nbsp}{nbsp}or{nbsp}{nbsp}{nbsp}stem:[1/2 + p + (k-1)/2]

^|k=0 ^|k=1

^|image:pcs-2-axe0.png[]
^|image:pcs-2-axe1.png[]

^a|`T~0~M11~2~([2]) -> [2]` +
stem:[m = 2 + 0/2 = 2]
^a|`T~1~M11~2~([2]) -> [3]` +
stem:[m = 1/2 + 2]

^| ^|
^|k=2 ^|k=3

^|image:pcs-2-axe2.png[]
^|image:pcs-2-axe3.png[]

^a|`T~2~M11~2~([2]) -> [4]` +
stem:[m = 2 + 2/2 = 3]
^a|`T~3~M11~2~([2]) -> [5]` +
stem:[m = 1/2 + 3]

|===

[TIP]
====
* When _k_ = _0_, the midpoint is stem:[p + 0 = p], thefore, the operation stem:[T_0M11_p]{nbsp} (stem:[M11_p]), denote an inversion around an axis passing through _p_ (axis of type A)

* When _k_ is odd, the midpoint is stem:[ 1/2 + w], where stem:[w = p + (k-1)/2], +
Since _(k - 1)_ is always even, _k_ odd always denotes a type B axis.

* When _k_ is even, the midpoint is stem:[p + k/2] always denote an even value, so an axis of type A.

So, when _k_ is even, the axis is type of A, otherwise the axis is of type B.
====


==== Determine k from p and axis


From stem:[T_kMa_p], inherited from stem:[I^(p, p+k)],  let _m_ be the midpoint of linear segment (p, p + k)

* stem:[ m = (p + (p+k))/2 ]

So

* stem:[ m = p + k/2]

From the equation {nbsp}stem:[p +k/2 - m = 0]


We can then determine each of the variables {nbsp}stem:[k] and stem:[p] as a function of the other two.

When we want to impose an axis of symmetry on the affine function with pivot, we can deduce _k_ from _m_ and _p_.

// k ?
// * stem:[ k/2 = m - p]
[.text-center]
stem:[ k = 2(m-p)]

So, knowing the target axis of symmetry and one p-value, then we can know the value of _k_.

Examples:

image:pcs-256-M11axis0.png[] : `T~0~M11~2~([2 5 6])` -> `[2 10 11]`

* midpoint-axis = 2 and pivot-value in {2 5 6}
** _p_ = 2, then _k_ = _2 x (2 - 2) = **0**_
** _p_ = 5, then _k_ = _2 x (2 - 5) = 2 x -3 = -6 = **6**_
** _p_ = 6, then _k_ = _2 x (2 - 6) = 2 * -4 = -8 = **4**_

Therefore:
`T~0~M11~2~([256])` = `T~6~M11~5~([256])` = `T~4~M11~6~([256])` -> `[2 10 11]`


image:pcs-256-M11-free-axe.png[] : `T~-3~M11~2~([2 5 6])` -> `[7 8 11]`

* midpoint-axis = .5 and pivot-value in {2 5 6}
** _p_ = 2, then _k_ = _2 x (.5 - 2) = 2 x -1.5 = **-3** = **9**_
** _p_ = 5, then _k_ = _2 x (.5 - 5) = 2 x -4.5 = -9 = **3**_
** _p_ = 6, then _k_ = _2 x (.5 - 6) = 2 x -5.5 = -11 = **1**_


Therefore:
`T~3~M11~5~([256])` = `T~1~M11~6~([256])` = `T~-3~M11~2~([256])` -> `[7 8 11]`

We can also deduce _p_ from _k_ and _m_, although this is unlikely to be a common use:

// p ?
//
// * stem:[ 2m -2p -k = 0]
// * stem:[ -2p -k = -2m]
// * stem:[ -2p  = k-2m]
// * stem:[ p  = (k-2m) / -2]
[.text-center]
stem:[ p  = m - k/ 2]


==== Enumeration of pairs per axis

Each pitch-class number can be associated with _n_ others pitch-class numbers, include itself, to identify _n_ symmetry axis.

Thus, there is, in total, _n x n_ = _**n^2^**_ possible pairs to identify axes.

See below for a more detailed way of establishing this result.

How many pairs (a, b) can identify an axis of a representative circle of stem:[ZZ_n]? +
Two cas, when _n_ is even or odd.

* When _n_ is even +
+
Let's take a *A-type* axis, the one passing through 0 (and _n/2_).
+
(n,n), (n+1,n-1), (n+2,n-2) ... (n/2,n/2), (n/2+1,n/2-1) ... (n-1,1)
+
so there are _n_ pairs (a,b) to define one axis.
+
Let us take _n = 12_
+
It has the following segments [a,b]: (0,0), (1,11), (2,10), (3,9), (4,8), (5,7), and (6,6), or 7, among them 5 are invertible, which makes, for one A-type axis, 5 x 2 + 2 = 12 possible pairs.
+
Let's take a *B-type* axis, the one passing between 0 and 1 (or 6 and 7).
+
It has the following segments [a,b]: (0,1), (11,2), (10,3), (9,4), (8,5), (7,6), or 6 invertible pairs = 12 possible pairs.
+
So when _n=12_, there are a total of 12x12 = 144 pairs (a,b).
+
Since there are n/2 A-type axes and n/2 B-type axes, and each type axe has _n_ pairs, this gives the total of pairs: _**n^2^**_


* When _n_ is odd +
+
Let’s take a *AB-type* axe passing by 0 (or _n_)
+
(n,n), (n+1,n-1), (n+2,n-2), (n+3,n-3) ... (n-1,1), so _n_ pairs
+
Let us tak _n = 7_
+
(0,0), (1,6), (2,5), (3,4), (4,3), (5,2), (6,1) => 7 = _n_
+
=> Seen another way, when _n_ is odd, any axis has one pair of form (a,a), self-inverse, and stem:[(n-1)/2] of invertible pairs (a,b). So, the number of pairs is stem:[2 ((n-1)/2) + 1 or n-1+1 = n]
+
Since there are _n_ axes, the total number of pairs is 7*7 = 49 = _**n^2^**_

====
[.text-center]
Conclusion +
whatever the parity of _n_


* The number of axis is  *_n_*

* The number of pair expressions allowing to identify one axis of symmetry is *_n_*

* The total of possible expressions of pairs (a,b) is therfore _n x n_ = _**n²**_, which we will restrict, for better processing consistency, to the cardinal of the pcs, expect the empty set, on which the _affine pivot_ function applies.
====

=== AffinePivot implementation

An typescript implementation of affine pivot logic : `[C]T~k~Ma~p~(pcs)`

This version works on a vector representation of a pcs (a bit array)

[source, javascript]
----
/** extended affinePivot transformation implementation
 * c . (ax + b) |-> c . (ax + p(1 − a) + k)
*  as a permutation of array's elements
 */
function affinePivot(
  p: number, // integer in [0..this.n-1],
         // assert: vectorIn[p] equals 1 if vectorIn not image of empty set else 0
  a: number, // integer, assert: a is coprime with 'n'
  k: number, // integer in Z
  vectorIn: number[], // array of 0 | 1, a vector image of a pcs
             // ex: [1,0,0,0,1,0,0,1,0,0,0,0] for {0 4 7} (C E G)
  c: boolean = false // if true, return complement of permutedVector (false by default)
) : number[] // return new vector "affinePivot" transformed
{
    const n = vectorIn.length
    let permutedVector : number[] = Array(n)
    // c . (ax + b) |-> c . (a * i + p(1 − a) + k)
    const b = p * (1-a) + k
    for (let i = 0, j; i < n; i++) {
      // j and i play the role of both index and pitch-class number
      j = (n + (a * i + b) % n) % n // force modulo to get value in [0..n-1]
      // if c then inverse vectorPcs[i] (0 <-> 1)
      permutedVector[j] = c ? 1 - vectorPcs[i] : vectorPcs[i]
    }
    return permutedVector
}
----

This function is extracted from a POC (and more) available on GitHub (code open source: https://github.com/ocapuozzo/musaicbox-app) and the latest demo version, runnable via a browser (front-end application) is available here: https://musaicsbox.org


