:imagesdir: ./assets/images

[#_affine_with_pivot]
== Revisited basic operations

(with pivot parameter for better basic operations)

As they stand, the generally accepted basic operations of musical set theory pose a logic problem that we raise here.



=== What's wrong with basic operations

Let us take the inversion operation (M11) as an example, but the problem raised here also applies to the transformations M5 and M7.

In the literature on post-tonal analysis, inversion operation can be found expressed in two forms which we will here call _inverseA_ and _inverseB_:

- stem:["inverseA"(Pcs) = { (n - x) mod n | x ∈ Pcs }] // basic version <<Forte>>

- stem:["inverseB"(Pcs) = { (n - 1) * x mod n | x ∈ Pcs }] // https://en.wikipedia.org/wiki/Multiplication_(music)[multiplicative version M11]

Example : C Major scale `[0 2 4 5 7 9 11]`

* _inverseA_(`[0 2 4 5 7 9 11]`) :

`0` -> `12 - 0` -> `#0#`

`2` -> `12 - 2` -> `#10#`

`4` -> `12 - 4` -> `#8#`

`5` -> `12 - 5` -> `#7#`

`7` -> `12 - 7` -> `#5#`

`9` -> `12 - 3` -> `#3#`

`11` -> `12 - 11` -> `#1#`

This gives : _inverseA_(`[0 2 4 5 7 9 11]`) -> `[#0 1 3 5 7 8 10#]`


* _inverseB_(`[0 2 4 5 7 9 11]`) :

`0` -> `11 x 0` -> `#0#`

`2` -> `11 x 2` -> 22 mod 12 -> `#10#`

`4` -> `11 x 4` -> 44 mod 12 -> `#8#`

`5` -> `11 x 5` -> 55 mod 12 -> `#7#`

`7` -> `11 x 7` -> 77 mod 12 -> `#5#`

`9` -> `11 x 3` -> 33 mod 12 -> `#3#`

`11` -> `11 x 11` -> 121 mod 12 -> `#1#`

This gives : _inverseB_(`[0 2 4 5 7 9 11]`) -> `[#0 1 3 5 7 8 10#]`

In fact, from a modulo n point of view, the functions _inverseA_ and _inverseB_ are the same. Proof.
|===
|inverseA|inverseB|Justification

|(n−x)|(n−1)⋅x|formulas
|(12−x)|(12−1)⋅x|n=12
|−x |11x |n modulo n = 0
|-1x|11x|-x = x multiply by -1
|*11x*|*11x*|-1 modulo 12 = 11 +

|===


Inverse operation transform CMajor into III degree of Ab Major, its VIb Major.

.M11 on C Major = III degree of Ab Major (VI-flat Major 'degree' of C)
image::CMajor-M11-noPivot.png[CMajor-M11]

Now that we have seen how the PCS Do Diatonic Major behaves, let's take C#/Db Diatonic Major: `[0 1 3 5 6 8 10]`


* The inverse of C# Major, _inverse_(`[0 1 3 5 6 8 10]`) :

`0` -> `12 - 0` -> `#0#`

`1` -> `12 - 1` -> `#11#`

`3` -> `12 - 3` -> `#9#`

`5` -> `12 - 5` -> `#7#`

`6` -> `12 - 6` -> `#6#`

`8` -> `12 - 8` -> `#4#`

`10` -> `12 - 10` -> `#2#`

_inverse_(`[0 1 3 5 6 8 10]`)  -> `[#0 2 4 6 7 9 11#]`

image::DbMajor-M11-noPivot.png[DbMajor-M11]

#⚠# *Oh!*, how comes the treatment of inversion for a C#/Db Major *differs* from that of a C Major?

The expected correct answer of Inverse(`[0 1 3 5 6 8 10]`)  should have been `[#1 2 4 6 8 9 11#]`, III degree of A Major (the VIb Major of Db Major) and not `[0 2 4 6 7 9 11]`.

Other example, with a _Limited Transposition_ scale : _C Dim7_

image::CDim7-infos.png[CDim7-infos]

As you might expect, a diminished seventh chord is *very strongly symmetrical*. Observe its stabilizers, there are 16 of them and 4 are in T0 (highlighted in yellow in the screenshot above) : `#T~0~M1#` of course, and  `#T~0~M5#`, `#T~0~M7#` and `#T~0~M11#`.

Let's summarize the different transformation operations of two diminished seventh chords: CDim7 [.nowrap]#(`[0 3 6 9]`)# and C#Dim7 [.nowrap]#(`[1 4 7 10]`)#.


// docinfo.html has a rule css for error red

[.text-center]
--

[#zero-fixed-problem]
.Basic operations in Musical Set Theory
[%header,cols="^,^,^,^,^"]
|===
|PCS|T~0~M11 (inversion) |T~0~M5|T~0~M7|Dim7 waiting as strongly invariant
a|{nbsp}  +
CDim7 ||||
|image:clock-0369.png[]|image:clock-0369.png[]|image:clock-0369.png[]|image:clock-0369.png[]| #OK#

|[0 3 6 9]|[0 3 6 9]|[0 3 6 9]|[0 3 6 9]| #OK#

a|{nbsp}  +
C#Dim7 ||||


|image:clock-14710.png[]|image:clock-25811.png[]|image:clock-25811.png[]|image:clock-14710.png[]|  #[2 5 8 11] should be [1{nbsp}4{nbsp}7{nbsp}10]#

|[1 4 7 10]|#[2 5 8 11]#|#[2 5 8 11]#|[1 4 7 10]| #?!#
|===

--

Obviously [2 5 8 11] is an intruder! business logic is not good. But then why is he here???

=== The "fixed zero problem"

The basic operations of musical set theory, which are the standard in the field, have a peculiarity: *they are always centered on _0_ (zero)footnote:[if _n_ is even, fixed points are _0_ and _n/2_]* , thus defining it as a fixed point we call the *_"fixed zero problem"_*.

The bad result we observed comes from the fact that the algorithms confuse index and pitch-class name, both being expressed by integers (a very useful confusion, by the way).

Calculations performed directly with these values lead to a falsely controlled side effect.

Example : `[1 4 7 10] x 11 = [11 44 70 110] modulo 12 = [11 8 5 2] => #[2 5 8 11]#`

As any musician would expect, the main characteristics of a PCS *should be insensitive to the transposition step* : the main characteristics of a PCS remain unchanged compared to those of the same PCS transposed by a _k-step_.

Indeed, the D-Major PCS share the same structural characteristics as any Major PCS, but we have noted that, in their basic form, the transformation operations, other than transposition, do not respect this constancy across all Major PCS.

[#Fixed-zero-problem]
====
[.text-center]
*_"Fixed zero problem"_*.

Generally speaking, the "fixed zero" has been identified as a problem by the Musical Set Theory, particularly in tonal system, and several solutions have been proposed.

* "_Babbitt and Perle develop "moveable-DO" systems. The zero residue is used to label the *first pitch-class* of the most significant row-form in any specific musical context_". <<LEWIN>>. We will see, with Db Major, that this is not a good solution. However, the idea is correct from the point of consistency, but should not be imposed but proposed as a default value.
* David Lewin proposes defining the LABEL function, which define a pitch-class reference for inversion, associates with a GIS (<<LEWIN>>, page 31).
* Later, David Lewin "frees" the LABEL function using a parameterized inversion operator _I^u,v^_, an inversion around an axis identified by a pair _(u, v)_, or a pitch-class _u_ if _u_ = _v_, then denoted by _I^u^_. <<LEWIN-1977a>> <<LEWIN-1980>>. Only deals with the case of inversion.
* Harald Fripertinger define in <<Fripertinger>> an _operator inversion, from Z to Z, with respect to r_  as [.nowrap]#_I~r~(i) = r − (i − r) = **2r - i**_#. So, when _r = 0_,  _I(i) = -i_. The parameter pitch-class reference _r_ (synonymous with pitch-class-pivot _p_) only deals with operator inversion, although fourth-circle and fifth-circle transformations are defined in the same paper.

====


[#understand-fixed-point-algorithm]
=== Idea for a solution

We are looking for a solution that allows to maintain the structural consistency of PCSs across different transformations, including inversion and transformation by cycles of fifths and fourths.

The David Lewin's operator (_I^u^_), and Harald Fripertinger inversion operator (_I~r~_) partially address this problem as they are reserved for inversion.

We propose to generalize this solution to the extended general affine function seen previously by adding a new parameter to designate the reference fixed point of transformation.

We start from the observation that the points fixed by the transformation operations depend essentially on _n_. For _n_ = 12, these fixed points are represented by this figure :

.Template of transformations (n = 12)
image::fixed-indexes-n12.png[fixed-indexes-n12]

In its basic form of the affine function _ax + k_, the first term is always fixed by _0_, whatever _x_. Zero is the guaranteed fixed point, whatever _n_. An inventory is necessary.

.Inventory of fixed points
[cols="^1,^1,^1,^1,^1"]
|===
| |ID |M11 |M5 |M7

|
.^|id
|image:M11-fixed.png[]
|image:M5-fixed.png[]
|image:M7-fixed.png[]

a|fixed-pitch-classes +
set
|{0,1,2,3,4,5,6,7,8,9,10,11}
|{0, 6}
|{0, 3, 6, 9}
|{0, 2, 4, 6, 8, 10}

|Intersection of fixed-pitch-classes sets
4+.^|{0,6}

|===


The axis of symmetry passing through zero, or six, denotes the canonical-axis of symmetry.

We decide to refer to this *canonical axis passing through zero*, in order to carry out the affine operations.

Note that, when _n_ is odd, axis passing through zero doesn't through any other pitch-class number. This is why we will only retain zero from now on.

Without calling into question the arithmetic based on pitch-class names, a general solution would be to align the PCS in question, via one of its pitch-classes, with the zero pitch-class before the transformation (M5, M7 or M11).

More precisely, this conceptually requires three operations, this is the price to pay for good consistency:

. Transpose, by a step ok _-p_, the PCS to make one of its PCs coincide with zero
. Apply the requested affine transformation (_ax + k_)
. perform an inverse transposition (_p_)

Some examples of inversion :

Example1 C-sharp Dim7 inversion : `T~0~M11` on `[1 4 7 10]`, (_p_=1)

. `[1 4 7 10]` transpose with `k = -p = -1` => `[0{nbsp}3{nbsp}6{nbsp}9]`
.  `[0 3 6 9]` x 11 modulo 12 => `[0{nbsp}3{nbsp}6{nbsp}9]`
. `[0 3 6 9]` transpose with `k = p = 1` => `#[1{nbsp}4{nbsp}7{nbsp}10]#`

Example2 D Major scale inversion : `T~0~M11~#2#~` on  `[1{nbsp}2{nbsp}4{nbsp}6{nbsp}7{nbsp}9{nbsp}11]` (_p_=2)

. `[1{nbsp}2{nbsp}4{nbsp}6{nbsp}7{nbsp}9{nbsp}11]` transpose of `p = -2` => `[0{nbsp}2{nbsp}4{nbsp}5{nbsp}7{nbsp}9{nbsp}11]`
. `[0{nbsp}2{nbsp}4{nbsp}5{nbsp}7{nbsp}9{nbsp}11]` x 11 modulo 12 =>
`[{nbsp}1{nbsp}3{nbsp}5{nbsp}7{nbsp}8{nbsp}10]`

. `[0{nbsp}1{nbsp}3{nbsp}5{nbsp}7{nbsp}8{nbsp}10]` transpose of `p = 2` => `#[0{nbsp}2{nbsp}3{nbsp}5{nbsp}7{nbsp}9{nbsp}10]#`

// use instead [.nowrap]

This solution is correct for all affine operations, but raises another problem: How to determine the value of _p_ ?
//as a transformation at the origin?

More possibilities:

A. *Choosing the "smallest PC"*.
 +
This choice is the same as first pitch-class of PCS in normal order. This is technically correct, but it is not always the right one: It works in the case of C# dim7, but not on D Major, [.nowrap]#[1 2 4 6 7 9 11]#, because its first and minimum pitch-class is 1 (C#), the seventh of the scale, and not the root of D major.

B. *Any PC from chromatic circle*
 +
"_There are twelve ways of inverting the total pc chromatic into itself, and any one of these twelve inversions may assume priority in a given musical context._" <<LEWIN-1977a>>.
 +
But this choice does not guarantee the consistency of transformation operations: Take a pitch-class that are not part of the pcs to be transformed cause a side effect. Such a pitch-class pollutes the pcs to be transformed during the transformation. See <<_whats_wrong_with_basic_operations>> when zero in not a pitch-class of the given pcs.

C.  *Any PC belonging to PCS to be transformed*
 +
This ensures that the transformation will be based on a pitch-class of the relevant PCS (acting as a "fixed zero").
 +
This solution is compatible with the idea of the solution, leaving the choice of the reference pitch-class, among _m_ choices, _m_ being the cardinal of the pcs concerned by the transformation. If pcs is seen as a chord, it can be the root position or an inverted chord, if pcs is seen as a scale, it is a degree of that scale. (we will apply solution A to define a default value)

It seems clear that solution C prevails. The pivot _p_ must be chosen from the PCS pitch-classes.

[#design-affine-pivot]
=== Affine operation with pivot

A solution to resolve mismatch basic operations is to add a parameter _p_ (pivot) to Extended Special Affine Operation.

The p-value consists, for a given PCS, of selecting a pitch-class that:

- Acts as a fixed point in affine operations (not necessarily "zero" or the first pitch-class)

- Belongs to the pitch-class set under study, expected the empty set.

We have seen that when we want to control the fixed point of a transformation operation of a PCS, a series of three operations is required: T~p~M1, [C]T~k~Ma~p~ and T~-p~M1. We call this operation _"AffinePivot"_, a right action.

====
[.text-center]
--
*_AffinePivot_~p,c,a,k~* +
_A composition of 3 affine operations_

stem:["AffinePivot"_(p,c,a,k)  : P(ZZ_n) xx NN xx bbb"B" xx NN xx ZZ -> P(ZZ_n)]

stem:["AffinePivot"_(p,c,a,k)(A) := T_pM1(A) @ C_cT_kMa(A) @ T_-pM1(A)]

_Where *a* is coprime with n, *k* a step of transposition, *c* if complement +
and a pivot value *p*, element of A or 0 if A is empty_

//stem:[  = {(a | a in A, if A != emptyset), (0, if A = emptyset) :}]

--
====


=== AffinePivot reduced

We are now preparing to establish a condensed version of the function.

stem:["AffinePivot"_(c,p,a,k)(A) := T_pM1(A) @ C_cT_kMa(A) @ T_-pM1(A)]

// Recall : Each extended affine function stem:[C_cM_aT_k] we can denote stem:[(c,a, k)], or stem:[(a, k)] when c=false, for the sake of simplification.

The extended affine composition function, that define one single function from composition of two functions, stem:[@],  is stem:[(c,a,k) @ (c',a',k') = (c oplus c', aa', ak' + k)]

We will use this affine reduction to reduce the composition of 3 functions, stem:[T_pM1(A) @ C_cT_kMa(A) @ T_-pM1(A)], to a single one.

*  stem:[(false, 1, p) @ (c, a, k) @ (false, 1, -p)]
* = stem:[(false, 1, p) @ (c oplus false, a, -ap + k)]
* = stem:[(false, 1, p) @ (c, a, -ap + k)] // c ⊕ false = c
* = stem:[(false oplus c, a, -ap + k + p)]
* = stem:[(c, a, -ap + k + p)]
* = #stem:[(c, a, p(1 - a) + k)]#  <= solution

TIP: Unsurprisingly, only the transposition step is affected. +
We will call this simplified function: *{startsb}C]T~k~Ma~p~* +
 +
*_C_*, for complement, is optional. We will see that *_p_* can also be, provided that a default value is applied by a deterministic algorithm.

// a * (x - pivot) + pivot + t // 1 mut 1 sous 2 add

// If we extract the affine part _ax + b_ :  (a,b) |-> stem:[(a, p(1 - a) + k)]

//
//
// .Examples
// --
//
// * With _p_ = 0
//
// - stem:[(a, p(1 - a) + k)]
// - stem:[(a, k)]  // ok this is initial function composition affine
//
// * With _p_ = 0 and _a_ = 1
//
// - stem:[(a, p(1 - a) + k)]
// - stem:[(1, k)]  // ok, simple transposition
//
// * With _p_ = _0_ and _a_ = _1_ and _k_ = _0_
//
// - stem:[(a, p(1 - a) + k)]
// - stem:[(1, 0)]  // ok, neutral operation (id)
//
// * With _p_ = 2 and _a_ = 11  and _k_ = _3_ (general use)
//
// - stem:[(a, p(1 - a) + k)]
// - stem:[(11, 2 * (1 - 11) + 3)]
// - stem:[(11, -17)]
// - stem:[(11, 7)] // modulo 12
//
// --

We can now define the operation that acts on PCS.


====
[.text-center]
--
*Affine with pivot : An action on PCS*


stem:[T_kMa_p  :  P(ZZ_n) xx ZZ xx NN xx NN -> P(ZZ_n)]


stem:[T_kMa_p(A) := {\ (ax + p(1 - a) + k) mod n \ },  forall  x in A]

_Where *a* is coprime with n, *k* a step of transposition, *p* an element of A or 0 if A is empty_

--
====


So, we can redefine special affine function with complement and pivot:

====
[.text-center]
--

*Extended special affine function with pivot*

[stem]
++++
[C]T_kMa_p(A) := { (T_kMa_p(A) \ \ \ \ \ \ \ if C " is not present"), (E\  \\ \ T_kMa_p(A)  if C " is present") :}
++++

--
====


////

[IMPORTANT]
====


Although the affinePivot function `CM~p~aTk` or `M~p~aTk`, has replaced the usual affine function `CMaTk` or `MaTk`, it should not be lost in sight that `[C]M~p~aTk` it is only a contraction of a composition of three basic affine functions:
[.nowrap]#`M1-Tp ∘ [C]Ma-Tk ∘ M1-T-p`# or [.nowrap]#`M1-T~p~([C]Ma-Tk(M1-T-p(pcs)))`#
as explained here <<design-affine-pivot>>.

====
////

=== Default pivot value

For compatibility with the usual affine function, as well as for practical reasons, we define the concept of default pivot value.

[#default-p-value-logic]
====
[.text-center]
--
*Default pivot value when AffinePivot act on a PCS*

The default p-value is the first pitch-class of the PCS or pitch-class zero if the PCS is empty set.

stem:[p = {(a | a in A, if A != emptyset), (0, if A = emptyset) :}]

By correlation, any pitch-class set in prime form has the default p-value equals to zero.
--
====

With the default pivot-value defined, we can simplify the writing of the affine transformation `T~k~Ma~p~` as `T~k~Ma` when `T~k~Ma~p~` acts on a PCS whose first pitch-class is equal to _p_.

Examples:

- (CMaj -> Fmin) `T~0~M11~0~([0 4 7])` =  `T~0~M11([0 4 7])` = `[0 5 8]`, pivot=0 and it is the first pitch-class

- (Fmaj -> Bbmin) `T~0~M11~5~([0 5 9])` =  `[1 5 10]`, pivot=5 is NOT the first pitch-class and must be specified.

- (FMaj/5th -> Cmin) `T~0~M11~0~([0 5 9])` = `T~0~M11([0 5 9])` =  `[0 3 7]`

- (C#dim7 -> C#dmin7) `T~0~M11~1~([1 4 7 10])` = `T~0~M11([1 4 7 10])` = `[1 4 7 10]`, pivot=1 and it is the first pitch-class

- (Db Major inversion) `T~0~M11~2~([1 2 4 6 7 9 11])` = `[1 2 4 6 8 9 11]`, The pivot must be specified, because the root is not the first pitch-class of the pcs.




=== Examples with affinePivot

Examples with p-value specified, or not.

.Revisited basic operations of Musical Set Theory, with pivot value (in red)
[%header,cols="^,^,^,^,^"]
|===
a|pcs +
source a|T~0~M11~0~ +
or +
T~0~M11 +
(inversion) a|T~0~M5~0~ +
or +
T~0~M5 a|T~0~M7~0~ +
or +
T~0~M7
|dim7 expected as strongly invariant

|image:pcs-0369-pivot0.png[]|image:pcs-0369-pivot0.png[]|image:pcs-0369-pivot0.png[]|image:pcs-0369-pivot0.png[] .^| Cdim7

|[0 3 6 9]|[0 3 6 9]|[0 3 6 9]|[0 3 6 9]| #OK#

|===

[%header,cols="^,^,^,^,^"]
|===
.^|(default p-value = 1) .^a|M11~1~T0 +
or +
T~0~M11 .^a|T~0~M5~1~ +
or +
T~0~M5 .^a|T~0~M7~1~ +
or +
T~0~M7 |dim7 expected as strongly invariant
|image:pcs-14710-pivot1.png[]|image:pcs-14710-pivot1.png[]|image:pcs-14710-pivot1.png[]|image:pcs-14710-pivot1.png[] .^|C#dim7

|[1 4 7 10]|[1 4 7 10]|[1 4 7 10]|[1 4 7 10]|#OK#
+
C#dim7 has same treatment as Cdim7

|===

[%header,cols="^,^,^,^,^"]
|===
.^a|CMajor +
p-value = 0 .^|T~0~M11  .^|T~0~M5  .^|T~0~M7|CMajor transformations (default pivot)

|image:pcs-CMaj-pivot0.png[]|image:pcs-CMaj-M11-pivot0.png[]|image:pcs-CMaj-M5-pivot0.png[]|image:pcs-CMaj-M7-pivot0.png[]|

|[0 2 4 5 7 9 11]|[0 1 3 5 7 8 10]|[0 1 7 8 9 10 11]|[0 1 2 3 4 5 11]|ok

|===


[%header,cols="^,^,^,^,^"]
|===
.^a|C Major +
p-value = 4 .^|T~0~M11~4~  .^|T~0~M5~4~  .^|T~0~M7~4~|C Major transformations (pivot=4)

|image:pcs-02457911-p4-clock.png[]|image:pcs-02457911-p4-clock-M11.png[]|image:pcs-02457911-p4-clock-M5.png[]|image:pcs-02457911-p4-clock-M7.png[]|

a|[0 2 4 5 7 9 11] +
C Maj/E a|[0 3 4 6 8 9 11] +
E Maj|[3 4 5 6 7 8 9]|[0 1 2 3 4 5 11] a|ok +
M11~4~(CMajor) +
map to EMajor

|===



[%header,cols="^,^,^,^,^"]
|===
.^a|(default p-value = 1) +
but p-value = 2 .^|T~0~M11~2~  .^|T~0~M5~2~  .^|T~0~M~2~7|DMajor transformations

|image:pcs-DMajor-pivot2.png[]|image:pcsDMaj-M11-Pivot2.png[]|image:pcsDMaj-M5-Pivot2.png[]|image:pcsDMaj-M7-Pivot2.png[]|

|[1 2 4 6 7 9 11] a|[0 2 3 5 7 9 10] +
Become III degree of Bb Major|[0 1 2 3 9 10 11]|[1 2 3 4 5 6 7]|OK DMajor with pivot=2 has same treatment as CMajor

|===
//
// [%header,cols="^,^,^,^,^"]
// |===
// .^| .^|T~4~CM11~0~  .^|T~4~CM5~0~  .^|T~4~CM7~0~|
//
// |image:pcs-047-pivot-0.png[]|image:pcs-047-pivot-0-CM11-T4.png[]|image:pcs-047-pivot-0-CM5-T4.png[]|image:pcs-047-pivot-0-CM7-T4.png[]| CMaj transformations
//
// |[0 4 7]|[12356781011]|[12567891011]|[01236791011]|
// |===
//
//
// [%header,cols="^,^,^,^,^"]
// |===
// a|CMaj +
// pivot on 3rd .^|T~4~CM11~4~  .^|T~4~CM5~4~  .^|T~4~CM7~4~|
//
// |image:pcs-047-pivot-4.png[]|image:pcs-047-pivot-4-CM11-T4.png[]|image:pcs-047-pivot-4-CM5-T4.png[]|image:pcs-047-pivot-4-CM7-T4.png[]| CMaj transformations
//
// |{startsb}0 4 7]|[12346791011]|[1234567910]|[01236791011]|
// |===
//

[%header,cols="^,^,^,^,^"]
|===
a|D#/Eb Schoenberg Hexachord +
(pivot on root) .^|CT~0~M11~3~  .^|CT~0~C5~3~  .^|CT~0~M7~3~|

|image:pcs-034589-pivot3.png[]|image:pcs-034589-pivot-3-CM11T0.png[]|image:pcs-034589-pivot-3-CM5T0.png[]|image:pcs-034589-pivot-3-CM7T0.png[]|D#/Eb Schoenberg Hexachord transformations

a|{startsb}0 3 4 5 8 9]|[0 4 5 7 8 11]|[2 5 6 7 10 11]|[0 1 4 7 8 11]|
|===


=== Simplified notation


|===
|operation type |affine |simplification

|Neutral operation
|`T~0~M1`
|`M1`

|Transposition
|`T~k~M1`
|`T~k~`

|Multiplication
|`T~0~Ma~p~`
|`Ma~p~`

|Complement
|`CT~0~M1`
|`C`

|Affine with transposition (k>0)
|`T~k~Ma~p~`
|`T~k~Ma~p~`

|Affine transposition + complement (k=0, a>1)
|`CT~0~Ma~p~`
|`CMa~p~`

|Affine with complement k>0, a=1
|`CT~k~M1`
|`CT~k~`

|Affine with complement k>0, a>1
|`CT~k~Ma~p~`
|`CT~k~Ma~p~`


|===


Focus on inversion `M11~p~` with affine pivot formula:  stem:[ax + p(1 - a) + k]

.AffinePivot inversion analysis : {startsb}C]T~k~Ma~p~(A) |-> M11~p~(A)
[%header,cols=".^,.^,.^,.^,.^,.^2"]
|===
^a|stem:[p] ^a|stem:[a] ^a|stem:[k] .>a|stem:[ax + p(1 - a) + k)]|_{startsb}C]T~k~Ma~p~(A)_ |designation
//
// |no present
// |no present
// |1
// |0
// a|stem:[x]
// a|`T~0~M1(A)` or +
// `M1(A)`
// |neutral operation
//
// |no present
// |no present
// |a
// |0
// a|stem:[ax]
// a|`T~0~Ma(A)` or +
//  `Ma(A)`
// |Mx transformation (*)
//
// |no present
// |no present
// |1
// |k
// .^a|stem:[x + k]
// .^a|`T~k~M1(A)`
// or +
// `T~k~(A)`
// |transposition
//
// |present
// |no present
// |1
// |0
// a|E - A
// a|`CT~0~M1(A)` or +
//  `C(A)`
// |complement

|p
|11
|0
a|
- 11x + p(1 - 11)
- 11x - 10p
- -1x + 2p (equiv. mod 12)
- *2p - x* +
Here we find the solution of Fripentinger <<Fixed-zero-problem>>
a|[.nowrap]#`T~0~M11~p~(A)`# or +
`M11~p~(A)`
|inversion "around" _p_

//
// |no present
// |no present
// |a
// |k
// a|stem:[ax + k]
// a|`T~k~Ma(A)`
// |initial affine function (*)
//
//
//
// |no present
// |2
// |11
// |3
// a|- stem:[(a, p(1 - a) + k)]
// - stem:[(11, 2 * (1 - 11) + 3)]
// - stem:[(11, -17)]
// - stem:[(11, 7)] // eq. modulo 12
// - stem:[11x + 7]
// .^a|[.nowrap]`T~3~M11~2~(A)`
// |example of traditional affine use, with pivot value = 2 (2 ∈ A)

|===
// (*) _a_ coprime with _n_

// And yet, the AffinePivot function has taken the place of the usual Affine functions in the project... Obviously to be clarified...

//
// === Composition AffineExtended function of (a, p(1 - a) + k)
//
// Composition function of traditional affine operation is
//
// stem:[(a,k) @ (a',k') = (aa', ak' + k)]
//
// which we apply to our extended function.
//
// Function composition stem:[@] is :
//
// - = stem:[(a, p(1 - a) + k) @ (a', p'(1 - a') + k')]
// - = stem:[(aa', a * (p'(1 - a') + k') + p(1 - a) + k)]
// - = stem:[(aa', -aa'p' + ap' +ak' -ap + p + k)]
// - = #stem:[(aa', -ap'(a + 1) + p(1-a) + ak' + k)]# <= solution
//
// Examples
//
// * With _p_ = 0 and p' = 0:
//
// - stem:[(aa', -ap'(a + 1) + p(1-a) + ak' + k)]
// - stem:[(aa', ak' + k)]  // ok this is initial function composition affine
//
// * With _p_ = _p'_ = 0 and _a_ = 1 and _a'_ = 1
//
// - stem:[(aa', -ap'(a + 1) + p(1-a) + ak' + k)]
// - stem:[(1, k' + k)]  // ok, simple transposition
//
// * With _p_ = _p'_ = _0_ and _a_ = _a'_ = _1_ and _k_ = _k'_ = _0_
//
// - stem:[(aa', -ap'(a + 1) + p(1-a) + ak' + k)]
// - stem:[(1, 0)]  // ok, neutral (or id) operation
//
// * With _p_ = 1 _p'_ = 2 and _a_ = 5  _a'_ = 7 and _k_ = 2 _k'_ = _3_
//
// - stem:[(aa', -ap'(a + 1) + p(1-a) + ak' + k)]
// - stem:[(35, -10(5 + 1) + (1-5) + 15 + 2)]
// - stem:[(11, 1)] // modulo 12


If we assume that the pitch-class set, in normal order, represents a scale, _p_ designates the degree from which the `T~k~Ma~p~` transformation will be applied. Not specifying _p_ in the affine `T~k~Ma` function triggers the default pivot value assignment logic (<<default-p-value-logic>>.


[#_free_axis_of_symmetry]
=== Free axis of symmetry

We have seen that any affine transformation, based on the pivot value, is guaranteed to operate "around" an axis passing through the *pitch-class-pivot*, in complete coherence.

The question is: Can we maintain this consistency while being free to select another axis of symmetry than the one passing through the pivot value?

The answer is YES, and we will see how.

Let us first start by knowing what are the different types of axes of symmetry of a circle having a homogeneous distribution of even and odd pitch-class numbers.


|===
^|n = 7 ^| n = 5 ^| n = 8 ^| n = 12

|image:pcs-emptyset-n7.png[]
|image:pcs-emptyset-n5.png[]
|image:pcs-emptyset-n8.png[]
|image:pcs-emptyset-n12.png[]

|===

As we can see, there are 3 ways to cut such a circle in half.

* A-type, passing _through_ two pitch-class
* B-type, passing twice between two pitch-class
* AB-type, passing _through_ one pitch-class and between two pitch-class

The kind of axes depends on the parity of _n_.

|===
^|n even ^|n odd

^|image:axis-symmetry-n8-A-B.png[]
^|image:pcs-emptyset-n7-axesAB.png[]

^|A and B
^|AB
|===

//
// .Two symmetry axis types (n=8) A through 0 and B, between 0 and 1
// image:axis-symmetry-n8.png[] image:pcs-emptyset-n7-axesAB.png[]

Note that when _n_ is odd, there is only one type of axis that is both intercalary [.underline]#and# median.

We immediately see that the pitch-class pivot value alone only allows us to define A-type and AB-type axes.

Examples with p-value = 2 : `T~0~M11~2~([24567]) = [0291011]`

image:pcs-24567-axe.png[] `T~0~M11~2~` -> image:pcs-0291011-axe.png[]

But what about the B-type axis, passing between pitch-classes?

For example, the operation below defines an axis of `[2 4 5 6 7]` passing through pitch-class numbers *_2_* and *_3_*.

image:pcs-24567-axe-B.png[] `??` -> image:pcs-0131011-axe-B.png[]

Let's take a closer look at the affine function with pivot.

In the affinePivot transformation, defined in <<AffinePivot reduced>>, stem:[(ax + p(1 - a) + k)], each of these members has a dedicated role:

* stem:[ax + p(1 - a)] is executed first. That is the Mx transformation (M1,M5,M7,M11) center on p-value
* stem:[ + k ] {nbsp} is the transposition step, executed after "Mx pivot center" transformation

[.text-center]
stem:[ubrace(ax + p(1 - a))_("Ma center on p") ubrace(\ +\ \  k)_("transp step")]


Once the first transformation stem:[ax+p(1−a)] done, the role of stem:[k] is to allow the axis of symmetry to be moved to the *center* of the space cleared between stem:[p] and stem:[p+k]. Thus the axis is moved by a step equal to stem:[k/2]. In absolute value, the axis passes through the center of the circle of course and by stem:[(p+p+k)/2], or stem:[p+k/2].


Therefore, to move from A-type axis passing through 2 to a B-type axis passing between 2 and 3, we assign the value of stem:[k] to 1 in order to obtain an axis passing by stem:[2 + 1/2]

[.text-center]
image:pcs-24567-axe-B.png[] `T~1~M11~2~` -> image:pcs-0131011-axe-B.png[]

[.text-center]
Illustration how _k=1_ and _p=2_ define an B-type axis passing between _p_ and _p+k_


=== How to specify an axis

We saw that `T~k~M11~p~` allows us to designate an axis of symmetry passing by stem:[p + k/2].

// The following characteristics can be drawn from it:
//
// * an even stem:[k] denotes an axis of A-type (or AB-type)
// * an odd stem:[k]  denotes an axis of B-type (or AB-type)

when stem:[k = 0], the axis of symmetry passes through stem:[p] (axis of type A or AB) otherwise through an imaginary point distant from stem:[p] by stem:[k/2].  Examples with pcs [2]:

[.text-center]
image::pcs-2-more-axe.png[]
[.text-center]
_Example with pcs [2], p=pivot=2 and variations on k_, axis passing by stem:[p+k/2]

Examples with stem:[k] to stem:[0] and stem:[-3] {nbsp} (or stem:[9]):

image:pcs-256-M11axis0.png[] : `T~0~M11~2~([2 5 6])` -> `[2 10 11]`

image:pcs-256-M11-free-axe.png[] : `T~-3~M11~2~([2 5 6])` -> `[7 8 11]`

====
[.text-center]
In summary
//
// There are 3 kinds of axes, depending of the parity of _n_ :
//
// * _n_ even
// - A-type passing through two pitch-classes
// - B-type passing twice between two pitch-classes
//
// * _n_ odd
// - AB-type passing through one pitch-class and between two pitch-classes

To choose an axis of symmetry not passing through stem:[p], it is sufficient to give a value to stem:[k] different from a value equivalent to 0, the axis will pass through an imaginary point distant from stem:[p] by stem:[k/2].

Although there are _n_ ways to designate an axis of symmetry for a pcs that we will call A, we will limit the use to the pitch-classes belonging to A, for a reason of consistency explained in section <<Fixed-zero-problem>>.

The use of _p_ and _k_ to denote an axis of symmetry was inspired by the work of D. Lewin. As early as 1968, he began to study the influence of symmetry and the need to be able to select a particular axis in inversion operations.   For more information, see the appendix <<Axis and its identifiers>>.

====
